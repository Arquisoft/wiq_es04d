ifndef::imagesdir[:imagesdir: ../images]

[[section-pruebas]]
== Pruebas 游댌
Para asegurarnos del correcto funcionamiento de la aplicaci칩n y encontrar mejores para la misma se han realizado pruebas de todo tipo aqui est치n los resultados obtenidos.

=== Pruebas de Cobertura (Tests Unitarios)
Estas pruebas se han realizado para la comprobacion de cada componente de manera individual evaluando los diferentes casos de uso. Estas son las pruebas realizadas, divididas por componente.

==== Tests Gateway Service
* *should forward login request to auth service*: Verifica que las solicitudes de inicio de sesi칩n sean correctamente reenviadas al servicio de autenticaci칩n y que el token esperado sea retornado si las credenciales son correctas.
* *should forward add user request to user service*:
Comprueba que las solicitudes para agregar un nuevo usuario sean reenviadas al servicio de usuarios y que se reciba un ID de usuario como respuesta.
* *should handle errors from the auth service on login*:
Asegura que se manejen adecuadamente los errores durante el proceso de inicio de sesi칩n, como credenciales incorrectas, y que se retorne el mensaje de error apropiado.

* *should validate a token successfully*:
Verifica que el servicio pueda validar correctamente un token, devolviendo un estado de validez.

* *should handle validation error*:  
Comprueba que se manejen correctamente los errores al validar tokens inv치lidos, retornando el mensaje de error adecuado.

* *should forward get random questions request to generate service*:
Asegura que las solicitudes para obtener preguntas aleatorias sean correctamente reenviadas al servicio de generaci칩n y que las preguntas esperadas sean retornadas.

* *should forward get questions request to generate service*:
Verifica que las solicitudes para obtener preguntas sean correctamente reenviadas al servicio de generaci칩n y que se retornen las preguntas adecuadas.

* *should forward create question request to generate service*: 
Comprueba que las solicitudes para crear una nueva pregunta sean correctamente reenviadas al servicio de generaci칩n y que se devuelva un estado de 칠xito y el ID de la pregunta.

* *should forward update question request to generate service*:
Asegura que las solicitudes para actualizar una pregunta existente sean reenviadas al servicio de generaci칩n y que se retorne un estado de "OK".

* *should forward save history request to history service*:
Verifica que las solicitudes para guardar el historial de acciones del usuario sean correctamente reenviadas al servicio de historial y que se retorne un estado de 칠xito.

* *should forward get history request to history service*:
Comprueba que las solicitudes para obtener el historial de un usuario sean correctamente reenviadas al servicio de historial y que se retornen los datos esperados.

* *should handle error getting random questions from generate service*:
Asegura que se manejen correctamente los errores al obtener preguntas aleatorias del servicio de generaci칩n, retornando el mensaje de error apropiado.

* *should handle error getting questions from generate service*:
Verifica que se manejen correctamente los errores al obtener preguntas del servicio de generaci칩n, retornando el mensaje de error adecuado.

* *should handle error creating question in generate service*:
Comprueba que se manejen correctamente los errores al crear una nueva pregunta en el servicio de generaci칩n, retornando el mensaje de error correspondiente.

* *should handle error updating question in generate service*:
Asegura que se manejen correctamente los errores al actualizar una pregunta en el servicio de generaci칩n, retornando el mensaje de error apropiado.

* *should handle error saving history in history service*:
Verifica que se manejen correctamente los errores al guardar el historial en el servicio de historial, retornando el mensaje de error adecuado.

* *should handle error getting history from history service with query*:
Comprueba que se manejen correctamente los errores al obtener el historial desde el servicio de historial, usando una consulta espec칤fica y retornando el mensaje de error correspondiente.

==== Tests Question Service
* *Should generate questions /generatequestions*:
Verifica que el endpoint /generatequestions genere correctamente las preguntas solicitadas y las almacene en la base de datos. Se espera que se generen y cuenten 100 preguntas en la base de datos tras la ejecuci칩n.

* *Should get questions /question/randoms*:
Comprueba que el endpoint /question/randoms recupere y devuelva un n칰mero espec칤fico de preguntas aleatorias, en este caso, se espera que devuelva 5 preguntas.

* *Should get all questions GET /question*:
Testea que el endpoint GET /question recupere todas las preguntas existentes en la base de datos. En este caso, se insertan dos preguntas espec칤ficas y se verifica que ambas se retornen correctamente.

* *Should create a new question*:
Verifica que el endpoint POST /question permita crear una nueva pregunta y que esta se almacene correctamente en la base de datos. Se espera que la solicitud se complete con 칠xito (c칩digo de estado 201) y que los datos de la pregunta creada coincidan con los enviados en la solicitud.

* *Should update a question by ID*:
Prueba que el endpoint PATCH /question/:id actualice correctamente una pregunta existente en la base de datos seg칰n los datos proporcionados. Se verifica que la solicitud se complete con 칠xito (c칩digo de estado 200) y que los datos de la pregunta actualizada en la respuesta coincidan con los datos actualizados enviados.

* *Should delete a question by ID*:
Asegura que el endpoint DELETE /question/:id elimine correctamente una pregunta espec칤fica de la base de datos. Se espera que la solicitud se complete con 칠xito (c칩digo de estado 200) y que la pregunta ya no exista en la base de datos tras la eliminaci칩n.

==== Tests llamadas a Wikidata
- Wiki Call
* *should fetch and return data from Wikidata for a valid SPARQL query*: 
Este test eval칰a si la funci칩n wikiCall realiza correctamente una solicitud HTTP para recuperar datos desde Wikidata utilizando una consulta SPARQL v치lida. Especificaciones del test incluyen:
* Preparaci칩n de Datos Simulados: Configura un mock de node-fetch para simular una respuesta exitosa de la API de Wikidata. Esto implica establecer un JSON de respuesta que imita los datos que se esperar칤an de una consulta SPARQL real.
* Ejecuci칩n y Validaci칩n de la Consulta: Ejecuta wikiCall con una consulta SPARQL de prueba para verificar si procesa esta consulta adecuadamente y si retorna los datos correctos. Se espera que la funci칩n transforme la respuesta simulada en el formato adecuado para su uso posterior, en este caso, un arreglo que contiene un objeto vac칤o que representa una fila de resultado SPARQL.
* Verificaci칩n de la Llamada a fetch: Confirma que node-fetch se llam칩 exactamente una vez y con los par치metros correctos, incluyendo la URL de Wikidata con la consulta SPARQL codificada y los headers apropiados para aceptar JSON de resultados SPARQL.

- Wiki Query
* *deber칤a obtener preguntas de Wikidata y formatearlas correctamente*: 
Este test verifica que el m칠todo getQuestions de WikiQuery realice correctamente la llamada a wikiCall para obtener datos de Wikidata, y que luego formatee estos datos en el formato esperado para preguntas. Se realiza una configuraci칩n previa para simular respuestas de wikiCall que contienen preguntas y respuestas en un formato espec칤fico. El test comprueba que:
* wikiCall se llama correctamente con una consulta SPARQL formateada para seleccionar etiquetas de preguntas y respuestas.
* wikiCall se invoca una sola vez, asegurando que la funci칩n no realiza llamadas redundantes o innecesarias.
* El modelo Question se instancia correctamente con los argumentos esperados para cada elemento de los resultados simulados, incluyendo la validaci칩n del formato de las preguntas y las respuestas.
* Se verifica que el n칰mero de preguntas creadas y su formato coincidan con los datos proporcionados en los resultados simulados, asegurando que cada pregunta est치 bien formada con la estructura correcta y categor칤a especificada.

==== Tests Auth Service
* *Should perform a login operation /login*:
Este test verifica que el endpoint /login permita a un usuario existente realizar el inicio de sesi칩n correctamente. Comprueba que al enviar un nombre de usuario y contrase침a v치lidos, el sistema responde con un estado 200 y retorna la propiedad 'username' en el cuerpo de la respuesta, indicando que el proceso de autenticaci칩n fue exitoso.

* *Should reject login with incorrect credentials*:
Este test se asegura de que el endpoint /login rechace el intento de inicio de sesi칩n cuando las credenciales son incorrectas. En este caso, se env칤a una contrase침a err칩nea para un nombre de usuario existente. El test verifica que el servidor responda con un estado 401 y que el cuerpo de la respuesta contenga el mensaje de error 'Invalid credentials', indicando que las credenciales proporcionadas no son v치lidas.

* *Should require username and password fields for login*:
Este test eval칰a que el endpoint /login requiera tanto el nombre de usuario como la contrase침a para procesar una solicitud de inicio de sesi칩n. Aqu칤 se env칤a solo el nombre de usuario sin proporcionar una contrase침a. El test verifica que el servidor responda con un estado 500 y que el cuerpo de la respuesta contenga un mensaje de error, indicando que la solicitud est치 incompleta o mal formada.

* *Should validate a JWT token*:
Este test primero realiza un inicio de sesi칩n v치lido para obtener un token JWT y luego verifica la validez de ese token a trav칠s de otro endpoint. Tras obtener el token, se realiza una solicitud de validaci칩n para dicho token y se verifica que el servidor responda con un estado 200 y que el cuerpo de la respuesta indique que el token es v치lido (valid: true).

* *Should reject an invalid JWT token*:
Este test verifica la funcionalidad del sistema para rechazar tokens JWT que no son v치lidos. Se env칤a un token arbitrario (incorrecto) al endpoint de validaci칩n y se comprueba que el servidor responda con un estado 200, pero con el cuerpo de la respuesta indicando que el token no es v치lido (valid: false).

==== Tests History Service
* *POST /savehistory*:
* should save history entry for a new user that plays a game: Este test verifica que el endpoint /savehistory pueda crear una nueva entrada de historial para un usuario que no exist칤a previamente en la base de datos. Eval칰a si la entrada se almacena correctamente y si los datos devueltos en la respuesta coinciden con los datos enviados, incluyendo la correcta diferenciaci칩n entre preguntas acertadas y falladas.
* should update history entry for an existing user: Este test comprueba que el endpoint /savehistory actualice correctamente una entrada de historial existente para un usuario, sumando correctamente las nuevas jugadas, preguntas jugadas, preguntas acertadas y preguntas falladas a los totales previos.

* *GET /gethistory*:
* should get history entry for an existing user: Este test verifica que el endpoint /gethistory (con un query param) recupere correctamente la entrada de historial de un usuario existente. Eval칰a si los datos devueltos coinciden exactamente con los que est치n almacenados en la base de datos.
* should create new history entry for a non-existing user: Este test comprueba que el endpoint /gethistory sea capaz de manejar solicitudes para usuarios no existentes correctamente, retornando una entrada de historial con contadores en cero.

* *GET /gethistory/:username*:
* should get history entry for an existing user: Similar al test anterior bajo el endpoint /gethistory, pero esta vez utilizando una ruta con par치metro. Verifica si la solicitud a /gethistory/:username recupera correctamente la entrada de historial para un usuario espec칤fico usando la identificaci칩n del usuario en la URL, asegur치ndose de que todos los datos devueltos coincidan con los almacenados.

==== Tests User Service
* *should add a new user on POST /adduser*:
Esta prueba verifica que un usuario nuevo se pueda a침adir correctamente mediante el endpoint /adduser. Al enviar una solicitud POST con un nombre de usuario y contrase침a v치lidos, se espera que el servidor responda con un c칩digo de estado 200 y que el cuerpo de la respuesta contenga el nombre de usuario que fue a침adido.

* *should reject a user without a username*:
Prueba la validaci칩n del campo requerido para el nombre de usuario. Al intentar registrar un usuario sin proporcionar un nombre de usuario, se espera que el servidor responda con un c칩digo de estado 400 y un mensaje de error indicando que falta el campo requerido "username".

* *should reject a user without a password*:
Verifica que el servicio rechace las solicitudes para crear un usuario que no incluyan una contrase침a. Si se env칤a una solicitud sin una contrase침a, el servidor debe responder con un c칩digo de estado 400 y un mensaje de error que indique que falta el campo requerido "password".

* *should not allow adding a user with an existing username*: 
Asegura que no se pueda registrar m치s de un usuario con el mismo nombre de usuario. l intentar a침adir un usuario que ya existe en la base de datos, el servidor debe responder con un c칩digo de estado 400 y un mensaje indicando que el usuario ya existe.

* *should get all users correctly*:
Este test verifica que el endpoint /user funcione correctamente al recuperar todos los usuarios registrados. Se espera que el servidor responda con un c칩digo de estado 200 y que el cuerpo de la respuesta contenga una lista de usuarios, mostrando 칰nicamente sus nombres de usuario y fechas de creaci칩n.

* *should update an existing user*:
Este test verifica que el endpoint /user/:id actualice correctamente un usuario existente. Al enviar una solicitud PATCH con un nuevo nombre de usuario, se espera que el servidor responda con un c칩digo de estado 200 y que el cuerpo de la respuesta refleje la actualizaci칩n.

* *should handle deletion of a non-existent user correctly*:
Este test asegura que el servidor responda correctamente cuando se intenta eliminar un usuario que no existe. Al enviar una solicitud DELETE a /user/:id con un ID inexistente, se espera que el servidor responda con un c칩digo de estado 404 y un mensaje de error indicando que el usuario no fue encontrado.

* *should handle internal server error when getting users*:
Verifica que el servicio maneje correctamente los errores internos al intentar obtener la lista de usuarios. Si ocurre un error interno (simulado mediante un fallo en la conexi칩n a la base de datos, por ejemplo), se espera que el servidor responda con un c칩digo de estado 500.

==== Tests Componentes React
Estas pruebas han sido dise침adas para mejorar el coverage de la aplicacion y no tienen mayor objetivo que comprobar que los componentes se cargan de manera correcta, sin probar la funcionalidad, ya que de esta sen encargan los servicios, estos componentes son:

* About US
* Add User
* Ayuda
* Creditos
* P치gina de Error (404)
* Historial
* Home (Inicio)
* Jugar
* Login
* Ranking
* Card Items (del About Us)
* Footer
* Layout
* NavBar


=== Pruebas e2e
Estas pruebas estan enfocadas en el correcto funcionamiento de la aplicacion cuando el usuario interactua con ella. Haciendo que las p치ginas muestren los resultados esperados y redirijan de manera correcta.

Las features son:

* Register Form:
****
Feature: Registering a new user

Scenario: The user is not registered in the site
  Given An unregistered user
  When I fill the data in the form and press submit
  Then The user is registered and logged
****

* Jugar Form:
****
Feature: Game Initialization

Scenario: User Initiates a Game
    Given An unregistered user exists
    When the user enters their details on the register form and submits
    And the user is redirected to the homepage and logged in automatically
    And the user clicks the "Play" button on the homepage
    Then the questions should be displayed
****

* History Form:
****
Feature: Seeing the loged user history

Scenario: The user is not loged in the site
  Given A not loged user
  When Press history
  Then Redirected to login

Scenario: The user register in the site so he can see history
  Given A unregistered user, fill the register
  When I press history
  Then I see my history
****


=== Pruebas de carga
Se enfocar치n en evaluar c칩mo se comporta nuestro sistema bajo condiciones de alto tr치fico y uso intensivo. Este tipo de pruebas es crucial para identificar cuellos de botella y asegurar que nuestra aplicaci칩n pueda manejar eficientemente el volumen de usuarios y transacciones esperado en producci칩n, sin comprometer el rendimiento ni la estabilidad.
Se han realizado 2 pruebas de carga con diferente numero de usuarios simultaneos.
Las pruebas seguir치n el siguiente procedimiento sencillo, pero que servir치 para probar los servicios y como se comportan ante el estres generado por muchos usuarios:

. El usuario se logea en la pagina
. Juega una partida completa
. Ve su historial
. Hace logout 

Esto se realiza en el transcurso de 1 minuto.

Aqui los resultados de la primera prueba con 240 usuarios.

image::Pruebacarga240.png["Prueba de carga 240 usuarios"]

Estos son los resultados con 900 seguidores concurrentes.

image::Pruebacarga900.png["Prueba de carga 900 usuarios"]

Podemos observar que la primera prueba la soporta de manera mas o menos asumible. Sin embargo, la segunda prueba ya esta sorpasando el limite de usuarios concurrentes y empiezan a fallar los servicios.
Esto se debe principalmente a las bajas prestaciones de la maquina virtual, marcadas por el credito disponible como estudiantes que nos proporciona Azure.

=== Pruebas de usabilidad
En este apartado, nos centraremos en las pruebas de usabilidad, un componente esencial para asegurar que nuestro sistema sea intuitivo, eficiente y accesible para todos los usuarios. Este tipo de pruebas eval칰a la interacci칩n entre el usuario y la aplicaci칩n, con el objetivo de identificar 치reas de mejora en la interfaz de usuario que faciliten una mejor experiencia general.

Las pruebas se han dividido en iteraciones. En cada interacion hay 3 fases.

. Fase de pruebas, con un grupo de usuarios variado (no muy extenso) en cuanto a conocimientos y soltura en el area de la inform치tica donde los desarrolladores toman nota de las dificultades de los usuarios, sin intervenir, a no ser que sea estrictamente necesario.

. Fase de estudio de los resultado. El equipo de desarrolladores se reune y decide que mejoras se han de implementar basadas en las observacions de la fase anterior.

. Fase de Implementaci칩n. Las mejoras decididas se implementan y se repite el proceso, para comprobar que hay una mejoria en la usabilidad.

Debido al escaso tiempo de desarrollo tan solo se relizaran 2 iteracciones de estas pruebas. A continuaci칩n se detallan paso a paso se desarrollaron las pruebas.

==== 1춹 Iteracci칩n
. Se ha seleccionado el grupo de pruebas. El grupo consta de 2 personas con altos conocimientos de informatica, 2 personas con un nivel medio y 2 personas con un nivel bajo. Se deja al grupo trabajar mientras los desarrolladores observan.

. Los resultados obtenidos son los siguientes.
- El dise침o de la p치gina es bastante intuitivo en especial para los usuarios que tiene alto conocimiento. Los usuarios con bajo conocimiento necesitaron de una peque침a intervenci칩n por parte del observador.
- A los usuarios de nivel bajo se les hace dif칤cil tener que registrarse y a continuaci칩n, tener que logearse en la p치gina.
- Los usuarios se quejan de que no se muestre cuando se acierta o se falla una pregunta.
- Los usuario de nivel alto destacan que no hay restricciones en el nombre de usuario y la contrase침a.
- Dificultad en las preguntas.
- Fallos de formato en las preguntas.

. Las soluciones que se han aplicado a las observaciones tras debatir entre los desarrolladores son las siguientes.
- Agregar una p치gina de ayuda para los usuarios que no sepan que pasos seguir para jugar. Ya sea tener que registrase en la p치gina, como jugar o como usar la API (aunque la API tenga su documentacion).
- A침adir un peque침o aviso que te diga cuando se acierta o se falla la pregunta. Cuando se falla tambi칠n se mostrar치 la respuesta correcta.
- A침adir restricciones a la creaci칩n de usuarios. Nombre de usuario de m칤nimo 4 caracteres y contrase침a con m칤nimo una letra may칰scula y un n칰mero.
- Se han revisado las plantillas de preguntas con mayor dificultad y se han a침adido alguna mas sencilla.
- Se ha corregido los errores de formato de las respuestas donde existen fechas.


==== 2춹 Iteracci칩n
1. Para la segunda iteraccion se ha contado con un grupo m치s reducido por incompatibilidad en los horarios. Sin embargo, seguimos contando con un usuario de cada nivel. Los resultados observados de esta segunda y 칰ltima iteraci칩n se detallan a continuaci칩n.
2. Las observaciones han cambiado y se han solucionado pr치cticamente todos los problemas de la primera versi칩n, sin embargo, han aparecido problem치ticas nuevas.
- La observaci칩n mas importante de todos los usuarios es que no se puede recuperar la contrase침a en caso de que se le olvide al usuario.
- El c치lculo del Ranking es poco intuitivo.
- Los usuarios poco habituados a los juegos destacan que la velocidad de la entrada al juego es demasiado r치pida y no da tiempo a entrar en contexto.
- Posibilidad de borrar usuarios desde la API sin tener permisos especiales. Esta problem치tica afecta a los usuarios mas avanzados.
- Repetici칩n de las respuestas en la pregunta.

3. Debido a la falta de tiempo no se podr치n implementar todas las mejoras que habia planteadas, sin embargo, estas son las decisiones de mejora tomadas por el equipo de desarrolladores.
- La 칰nica mejora implementada, es evitar en la l칩gica de generaci칩n de preguntas que existan respuestas repetidas.
- Crear un sistema de recupearaci칩n de contrase침a, a traves del correo electr칩nico, por lo habr칤a que modificar el registro de usuarios.
- Monitorizar el c치lculo del Ranking y valorar en el futuro si es correcto o hay que cambiarlo.
- Introducir una cuenta atr치s cuando le das a jugar una partida nueva para que al usuario de tiempo a entrar en contexto.
- A침adir permisos de usuario para realizar acciones especiales en la p치gina y asi poder borrar o editar usuario a traves de la API.

==== 3춹 Iteraccion?
Para probar la versi칩n final de la aplicaci칩n que se entregar치 a los profesores, se ha realizado una 칰ltima prueba para comprobar el correcto funcionamiento de todo con un par de usuarios ajeno a la aplicaci칩n. Su nivel es medio y alto.
Han destacado que todo es correcto en general (Obviando los puntos de la 2춹 iteracci칩n).

==== Conclusiones
Las pruebas de usabilidad han sido de gran utilidad para introducir mejoras en la aplicaci칩n, pero sobre todo han ayudado para dar un enfoque externo y m치s cr칤tico a nuestra aplicaci칩n.